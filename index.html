<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Interactive Orrery - with Calendar Picker & Kuiper Belt</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #202020;
      color: #fff;
      font-family: sans-serif;
    }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
    }
    #controls button,
    #controls input {
      margin: 5px;
      padding: 5px;
      background: #333;
      color: #fff;
      border: none;
      border-radius: 3px;
      cursor: pointer;
    }
    /* We no longer rely on type="date" since Safari won't show a dropdown. v10
       Instead we use Pikaday, so we do <input type="text"> and let Pikaday handle the calendar. */
    #dateSelector {
      width: 120px;
      background: #fff;
      color: #000;
      border-radius: 3px;
      border: 1px solid #ccc;
      padding: 3px;
    }
    #timeSlider {
      width: 200px;
      margin-top: 5px;
    }
    .dark-mode {
      background-color: #202020;
      color: #fff;
    }
  </style>

  <!-- Pikaday CSS -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pikaday/css/pikaday.css">
  <!-- Moment.js (required by Pikaday for date formatting) -->
  <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/moment.min.js"></script>
  <!-- Pikaday for a cross-browser date picker -->
  <script src="https://cdn.jsdelivr.net/npm/pikaday@1.8.2/pikaday.js"></script>
</head>
<body>
  <div id="controls">
    <div>
      <label for="dateSelector">Select Date:</label>
      <input type="text" id="dateSelector" placeholder="YYYY-MM-DD">
      <button id="currentDateBtn">Today</button>
    </div>
    <div>
      <label for="timeSlider">Time Slider (days offset):</label>
      <input type="range" id="timeSlider" min="0" max="3650" step="1" value="0">
    </div>
    <div>
      <button id="darkModeToggle">Toggle Dark Mode</button>
      <button id="resetViewBtn">Reset View</button>
    </div>
  </div>

  <canvas id="canvas"></canvas>

  <!-- Three.js and OrbitControls (non-module, from r127) -->
  <script src="./js/three.min.js"></script>
  <script src="./js/controls/OrbitControls.js"></script>

  <script>
    console.log("Three.js and OrbitControls loaded.");

    // Quick checks
    if (typeof THREE === "undefined") {
      console.error("THREE is not loaded!");
    }
    if (typeof THREE.OrbitControls === "undefined") {
      console.error("OrbitControls are not loaded!");
    }

    // Core variables
    let scene, camera, renderer, controls;
    let raycaster, mouse;
    let celestialObjects = [];
    const baseDate = new Date("2000-01-01T00:00:00"); // Reference epoch
    let simulationDate = new Date();
    const oneDay = 1000 * 60 * 60 * 24; // 1 day in ms

    // DOM elements
    const currentDateBtn = document.getElementById('currentDateBtn');
    const timeSlider = document.getElementById('timeSlider');
    const darkModeToggle = document.getElementById('darkModeToggle');
    const resetViewBtn = document.getElementById('resetViewBtn');
    const dateField = document.getElementById('dateSelector');

    // PIKADAY: cross-browser date picker
    let pikaday = new Pikaday({
      field: dateField,
      format: 'YYYY-MM-DD',
      onSelect: function(date) {
        // Update the simulation date and slider whenever user picks from calendar
        simulationDate = date;
        const daysOffset = Math.floor((simulationDate - baseDate) / oneDay);
        timeSlider.value = daysOffset;
        console.log("Date changed via Pikaday to:", simulationDate);
      }
    });

    // Set initial date in the date picker
    pikaday.setDate(simulationDate, true); // 'true' to not trigger onSelect

    // Sync the slider to the current date
    timeSlider.value = Math.floor((simulationDate - baseDate) / oneDay);

    // Listen for manual changes on the slider
    timeSlider.addEventListener('input', () => {
      const daysOffset = parseInt(timeSlider.value);
      simulationDate = new Date(baseDate.getTime() + daysOffset * oneDay);
      // Also update the date picker
      pikaday.setDate(simulationDate, true);
      console.log("Time slider updated simulation date to:", simulationDate);
    });

    // "Today" button
    currentDateBtn.addEventListener('click', () => {
      simulationDate = new Date();
      pikaday.setDate(simulationDate, true);
      timeSlider.value = Math.floor((simulationDate - baseDate) / oneDay);
      console.log("Simulation date reset to current date:", simulationDate);
    });

    // Dark mode toggle
    darkModeToggle.addEventListener('click', () => {
      document.body.classList.toggle('dark-mode');
      if (document.body.classList.contains('dark-mode')) {
        renderer.setClearColor(0x202020);
        console.log("Dark mode activated.");
      } else {
        renderer.setClearColor(0xffffff);
        console.log("Dark mode deactivated.");
      }
    });

    // Reset view
    resetViewBtn.addEventListener('click', () => {
      camera.position.set(0, 50, 100);
      controls.target.set(0, 0, 0);
      console.log("View reset to default.");
    });

    // Init Three.js scene
    init();
    animate();

    function init() {
      console.log("Initialization started.");
      const canvas = document.getElementById('canvas');
      if (!canvas) {
        console.error("Canvas element not found!");
        return;
      }

      renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x202020);
      console.log("Renderer created.");

      scene = new THREE.Scene();
      console.log("Scene created.");

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 50, 100);
      console.log("Camera created at position:", camera.position);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      console.log("OrbitControls initialized.");

      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();
      console.log("Raycaster and mouse vector created.");

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);

      const pointLight = new THREE.PointLight(0xffffff, 1.5);
      pointLight.position.set(0, 0, 0); // Our "Sun" is the light source
      scene.add(pointLight);

      // Create the Sun
      const sunGeometry = new THREE.SphereGeometry(3, 32, 32);
      const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
      const sun = new THREE.Mesh(sunGeometry, sunMaterial);
      sun.name = "Sun";
      scene.add(sun);
      celestialObjects.push({ mesh: sun, type: 'sun' });

      // Planet data
      const planetsData = [
        { name: "Mercury", radius: 4,  period: 88,   size: 0.5, color: 0xaaaaaa, moons: [] },
        { name: "Venus",   radius: 7,  period: 225,  size: 0.8, color: 0xffcc66, moons: [] },
        { name: "Earth",   radius: 10, period: 365,  size: 0.9, color: 0x2233ff, moons: [
            { name: "Moon", orbit: 1.5, period: 27,   size: 0.3, color: 0x888888 }
          ] },
        { name: "Mars",    radius: 13, period: 687,  size: 0.7, color: 0xff3300, moons: [
            { name: "Phobos", orbit: 1,   period: 0.3, size: 0.15, color: 0x999999 },
            { name: "Deimos", orbit: 1.5, period: 1.3, size: 0.1,  color: 0xbbbbbb }
          ] },
        { name: "Jupiter", radius: 17, period: 4333, size: 2,   color: 0xffaa77, moons: [
            { name: "Io",       orbit: 2.5, period: 1.8,  size: 0.3,  color: 0xffddaa },
            { name: "Europa",   orbit: 3,   period: 3.5,  size: 0.28, color: 0xffffff },
            { name: "Ganymede", orbit: 3.5, period: 7,    size: 0.4,  color: 0xcccccc },
            { name: "Callisto", orbit: 4,   period: 16,   size: 0.35, color: 0x999999 }
          ] },
        { name: "Saturn",  radius: 21, period: 10759, size: 1.8, color: 0xffeeaa, moons: [
            { name: "Titan",     orbit: 3, period: 16,  size: 0.4, color: 0xffcc99 },
            { name: "Enceladus", orbit: 2, period: 1.4, size: 0.2, color: 0xdddddd }
          ] },
        { name: "Uranus",  radius: 25, period: 30687, size: 1.5, color: 0x66ccff, moons: [
            { name: "Titania", orbit: 2.5, period: 8,  size: 0.3, color: 0xccccff },
            { name: "Oberon",  orbit: 3,   period: 12, size: 0.3, color: 0xbbbbff }
          ] },
        { name: "Neptune", radius: 29, period: 60190, size: 1.5, color: 0x3366ff, moons: [
            { name: "Triton", orbit: 3, period: 5, size: 0.35, color: 0x9999ff }
          ] },
        { name: "Pluto",   radius: 33, period: 90560, size: 0.6, color: 0xcccccc, moons: [
            { name: "Charon", orbit: 1.5, period: 6.4, size: 0.3, color: 0x888888 }
          ] }
      ];

      // Create planets
      planetsData.forEach(planet => {
        const planetGroup = new THREE.Group();
        const geometry = new THREE.SphereGeometry(planet.size, 32, 32);
        const material = new THREE.MeshStandardMaterial({ color: planet.color });
        const planetMesh = new THREE.Mesh(geometry, material);
        planetMesh.name = planet.name;
        planetGroup.add(planetMesh);

        planetGroup.userData = {
          orbitRadius: planet.radius,
          orbitalPeriod: planet.period,
          initialAngle: Math.random() * Math.PI * 2,
          moons: []
        };

        // Moons
        planet.moons.forEach(moon => {
          const moonGeometry = new THREE.SphereGeometry(moon.size, 16, 16);
          const moonMaterial = new THREE.MeshStandardMaterial({ color: moon.color });
          const moonMesh = new THREE.Mesh(moonGeometry, moonMaterial);
          moonMesh.position.x = moon.orbit;
          moonMesh.name = moon.name;
          const moonPivot = new THREE.Group();
          moonPivot.add(moonMesh);

          moonPivot.userData = {
            orbitRadius: moon.orbit,
            orbitalPeriod: moon.period,
            initialAngle: Math.random() * Math.PI * 2
          };

          planetGroup.add(moonPivot);
          planetGroup.userData.moons.push(moonPivot);
          console.log(`Moon ${moon.name} added to planet ${planet.name}.`);
        });

        scene.add(planetGroup);
        celestialObjects.push({ mesh: planetGroup, type: 'planet', data: planet });
        console.log(`Planet ${planet.name} created with orbit radius ${planet.radius}.`);
      });

      // "Kuiper Belt" or "Asteroid Belt" (whichever you prefer) out beyond Pluto:
      const beltGroup = new THREE.Group();
      const beltCount = 100;
      for (let i = 0; i < beltCount; i++) {
        const asteroidGeometry = new THREE.SphereGeometry(0.1, 8, 8);
        const asteroidMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });
        const asteroid = new THREE.Mesh(asteroidGeometry, asteroidMaterial);

        // Place them between 35 and 40 radius (beyond Pluto at 33)
        const angle = Math.random() * Math.PI * 2;
        const distance = 35 + Math.random() * 5; 
        asteroid.position.set(distance * Math.cos(angle), (Math.random() - 0.5) * 1, distance * Math.sin(angle));

        beltGroup.add(asteroid);
      }
      scene.add(beltGroup);
      console.log(`"Kuiper" belt created with ${beltCount} objects.`);

      // Voyager probe (the red lego block)
      const probeGeometry = new THREE.BoxGeometry(0.5, 0.5, 1);
      const probeMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
      const probe = new THREE.Mesh(probeGeometry, probeMaterial);
      probe.name = "Voyager"; // The red block
      probe.userData = {
        orbitRadius: 38,         // Just beyond Pluto
        orbitalPeriod: 150000,   // Arbitrary slow orbit
        initialAngle: Math.random() * Math.PI * 2
      };
      scene.add(probe);
      celestialObjects.push({ mesh: probe, type: 'probe' });
      console.log("Probe 'Voyager' added to the scene.");

      // Event listeners
      window.addEventListener('click', onMouseClick, false);
      window.addEventListener('resize', onWindowResize, false);
      console.log("Event listeners added.");
    }

    // Recalculate positions based on the simulation date
    function updatePositions() {
      const diffTime = simulationDate - baseDate;
      const diffDays = diffTime / oneDay;

      scene.traverse(child => {
        // Planets or groups with orbit data
        if (child.type === "Group" && child.userData.orbitRadius) {
          const orbitRadius = child.userData.orbitRadius;
          const period = child.userData.orbitalPeriod;
          const angle = child.userData.initialAngle + (2 * Math.PI * (diffDays / period));
          child.position.set(orbitRadius * Math.cos(angle), 0, orbitRadius * Math.sin(angle));

          // Moons revolve around their planet
          if (child.userData.moons) {
            child.userData.moons.forEach(moonPivot => {
              const mPeriod = moonPivot.userData.orbitalPeriod;
              const mAngle = moonPivot.userData.initialAngle + (2 * Math.PI * (diffDays / mPeriod));
              moonPivot.rotation.y = mAngle;
            });
          }
        }
        // Probe orbit
        if (child.userData.orbitRadius && child.name === "Voyager") {
          const orbitRadius = child.userData.orbitRadius;
          const period = child.userData.orbitalPeriod;
          const angle = child.userData.initialAngle + (2 * Math.PI * (diffDays / period));
          child.position.set(orbitRadius * Math.cos(angle), 0, orbitRadius * Math.sin(angle));
        }
      });
    }

    function onMouseClick(event) {
      event.preventDefault();
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(scene.children, true);
      console.log("Number of intersects:", intersects.length);
      if (intersects.length > 0) {
        const obj = intersects[0].object;
        const targetPosition = new THREE.Vector3();
        obj.getWorldPosition(targetPosition);
        console.log("Clicked object:", obj.name, "at", targetPosition);

        // Smooth camera move
        const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
        const newCameraPos = targetPosition.clone().add(direction.multiplyScalar(10));
        let t = 0;
        const duration = 60;
        const initialPos = camera.position.clone();
        const initialTarget = controls.target.clone();

        function animateCamera() {
          t++;
          const factor = t / duration;
          camera.position.lerpVectors(initialPos, newCameraPos, factor);
          controls.target.lerpVectors(initialTarget, targetPosition, factor);
          if (t < duration) {
            requestAnimationFrame(animateCamera);
          } else {
            console.log("Camera animation complete.");
          }
        }
        animateCamera();
      }
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      console.log("Window resized. New dimensions:", window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      updatePositions();
      controls.update();
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
