<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Interactive Orrery Simulation - Debug Version</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #202020;
      color: #fff;
      font-family: sans-serif;
    }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
      border-radius: 5px;
    }
    #controls input, #controls button {
      margin: 5px;
      padding: 5px;
      background: #333;
      color: #fff;
      border: none;
      border-radius: 3px;
      cursor: pointer;
    }
    #controls input[type="date"] {
      color: #000;
    }
    .dark-mode {
      background-color: #202020;
      color: #fff;
    }
  </style>
</head>
<body>
  <div id="controls">
    <label for="dateSelector">Select Date:</label>
    <input type="date" id="dateSelector">
    <button id="currentDateBtn">Today</button>
    <button id="darkModeToggle">Toggle Dark Mode</button>
    <button id="resetViewBtn">Reset View</button>
  </div>
  <canvas id="canvas"></canvas>

  <!-- Module-based imports for Three.js and OrbitControls v3-->
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/OrbitControls.js';
    console.log("Modules loaded: THREE and OrbitControls.");

    let scene, camera, renderer, controls;
    let raycaster, mouse;
    let celestialObjects = [];
    let baseDate = new Date("2000-01-01T00:00:00"); // Reference epoch
    let simulationDate = new Date();

    init();
    animate();

    function init() {
      console.log("Initialization started.");
      const canvas = document.getElementById('canvas');
      if (!canvas) {
        console.error("Canvas element not found!");
        return;
      }
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      console.log("Renderer created.");
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x202020);
      scene = new THREE.Scene();
      console.log("Scene created.");

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 50, 100);
      console.log("Camera created at position:", camera.position);

      controls = new OrbitControls(camera, renderer.domElement);
      console.log("OrbitControls initialized.");

      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();
      console.log("Raycaster and mouse vector created.");

      // Lighting
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      console.log("Ambient light added.");
      const pointLight = new THREE.PointLight(0xffffff, 1.5);
      pointLight.position.set(0, 0, 0); // Sun as the light source
      scene.add(pointLight);
      console.log("Point light added at:", pointLight.position);

      // Create the Sun
      const sunGeometry = new THREE.SphereGeometry(3, 32, 32);
      const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
      const sun = new THREE.Mesh(sunGeometry, sunMaterial);
      sun.name = "Sun";
      scene.add(sun);
      celestialObjects.push({ mesh: sun, type: 'sun' });
      console.log("Sun created and added to scene.");

      // Define planetary data: each with moons, orbit radii, periods, etc.
      const planetsData = [
        { name: "Mercury", radius: 4, period: 88, size: 0.5, color: 0xaaaaaa, moons: [] },
        { name: "Venus",   radius: 7, period: 225, size: 0.8, color: 0xffcc66, moons: [] },
        { name: "Earth",   radius: 10, period: 365, size: 0.9, color: 0x2233ff, moons: [
            { name: "Moon", orbit: 1.5, period: 27, size: 0.3, color: 0x888888 }
          ] },
        { name: "Mars",    radius: 13, period: 687, size: 0.7, color: 0xff3300, moons: [
            { name: "Phobos", orbit: 1, period: 0.3, size: 0.15, color: 0x999999 },
            { name: "Deimos", orbit: 1.5, period: 1.3, size: 0.1, color: 0xbbbbbb }
          ] },
        { name: "Jupiter", radius: 17, period: 4333, size: 2, color: 0xffaa77, moons: [
            { name: "Io", orbit: 2.5, period: 1.8, size: 0.3, color: 0xffddaa },
            { name: "Europa", orbit: 3, period: 3.5, size: 0.28, color: 0xffffff },
            { name: "Ganymede", orbit: 3.5, period: 7, size: 0.4, color: 0xcccccc },
            { name: "Callisto", orbit: 4, period: 16, size: 0.35, color: 0x999999 }
          ] },
        { name: "Saturn",  radius: 21, period: 10759, size: 1.8, color: 0xffeeaa, moons: [
            { name: "Titan", orbit: 3, period: 16, size: 0.4, color: 0xffcc99 },
            { name: "Enceladus", orbit: 2, period: 1.4, size: 0.2, color: 0xdddddd }
          ] },
        { name: "Uranus",  radius: 25, period: 30687, size: 1.5, color: 0x66ccff, moons: [
            { name: "Titania", orbit: 2.5, period: 8, size: 0.3, color: 0xccccff },
            { name: "Oberon", orbit: 3, period: 12, size: 0.3, color: 0xbbbbff }
          ] },
        { name: "Neptune", radius: 29, period: 60190, size: 1.5, color: 0x3366ff, moons: [
            { name: "Triton", orbit: 3, period: 5, size: 0.35, color: 0x9999ff }
          ] },
        { name: "Pluto",   radius: 33, period: 90560, size: 0.6, color: 0xcccccc, moons: [
            { name: "Charon", orbit: 1.5, period: 6.4, size: 0.3, color: 0x888888 }
          ] }
      ];

      // Create planets and their moons
      planetsData.forEach(planet => {
        const planetGroup = new THREE.Group();
        const geometry = new THREE.SphereGeometry(planet.size, 32, 32);
        const material = new THREE.MeshStandardMaterial({ color: planet.color });
        const planetMesh = new THREE.Mesh(geometry, material);
        planetMesh.name = planet.name;
        planetGroup.add(planetMesh);
        planetGroup.userData = {
          orbitRadius: planet.radius,
          orbitalPeriod: planet.period,
          initialAngle: Math.random() * Math.PI * 2,
          moons: []
        };
        planet.moons.forEach(moon => {
          const moonGeometry = new THREE.SphereGeometry(moon.size, 16, 16);
          const moonMaterial = new THREE.MeshStandardMaterial({ color: moon.color });
          const moonMesh = new THREE.Mesh(moonGeometry, moonMaterial);
          moonMesh.position.x = moon.orbit;
          moonMesh.name = moon.name;
          const moonPivot = new THREE.Group();
          moonPivot.add(moonMesh);
          moonPivot.userData = {
            orbitRadius: moon.orbit,
            orbitalPeriod: moon.period,
            initialAngle: Math.random() * Math.PI * 2
          };
          planetGroup.add(moonPivot);
          planetGroup.userData.moons.push(moonPivot);
          console.log(`Moon ${moon.name} added to planet ${planet.name}.`);
        });
        scene.add(planetGroup);
        celestialObjects.push({ mesh: planetGroup, type: 'planet', data: planet });
        console.log(`Planet ${planet.name} created with orbit radius ${planet.radius}.`);
      });

      // Create an asteroid belt
      const asteroidGroup = new THREE.Group();
      const asteroidCount = 100;
      for (let i = 0; i < asteroidCount; i++) {
        const asteroidGeometry = new THREE.SphereGeometry(0.1, 8, 8);
        const asteroidMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });
        const asteroid = new THREE.Mesh(asteroidGeometry, asteroidMaterial);
        const angle = Math.random() * Math.PI * 2;
        const distance = 15 + Math.random() * 2;
        asteroid.position.set(distance * Math.cos(angle), (Math.random() - 0.5) * 0.5, distance * Math.sin(angle));
        asteroidGroup.add(asteroid);
      }
      scene.add(asteroidGroup);
      console.log("Asteroid belt created with", asteroidCount, "asteroids.");

      // Add a probe (Voyager)
      const probeGeometry = new THREE.BoxGeometry(0.5, 0.5, 1);
      const probeMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
      const probe = new THREE.Mesh(probeGeometry, probeMaterial);
      probe.name = "Voyager";
      probe.userData = {
        orbitRadius: 38,
        orbitalPeriod: 150000,
        initialAngle: Math.random() * Math.PI * 2
      };
      scene.add(probe);
      celestialObjects.push({ mesh: probe, type: 'probe' });
      console.log("Probe 'Voyager' added to the scene.");

      // UI Controls for date selection and toggles
      const dateSelector = document.getElementById('dateSelector');
      const currentDateBtn = document.getElementById('currentDateBtn');
      dateSelector.valueAsDate = new Date();
      dateSelector.addEventListener('change', (e) => {
        simulationDate = new Date(e.target.value);
        console.log("Simulation date changed to:", simulationDate);
      });
      currentDateBtn.addEventListener('click', () => {
        simulationDate = new Date();
        dateSelector.valueAsDate = simulationDate;
        console.log("Simulation date reset to current date:", simulationDate);
      });
      
      const darkModeToggle = document.getElementById('darkModeToggle');
      darkModeToggle.addEventListener('click', () => {
        document.body.classList.toggle('dark-mode');
        if (document.body.classList.contains('dark-mode')) {
          renderer.setClearColor(0x202020);
          console.log("Dark mode activated.");
        } else {
          renderer.setClearColor(0xffffff);
          console.log("Dark mode deactivated.");
        }
      });

      const resetViewBtn = document.getElementById('resetViewBtn');
      resetViewBtn.addEventListener('click', () => {
        camera.position.set(0, 50, 100);
        controls.target.set(0, 0, 0);
        console.log("View reset to default.");
      });

      window.addEventListener('click', onMouseClick, false);
      window.addEventListener('resize', onWindowResize, false);
      console.log("Event listeners added.");
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      console.log("Window resized. New dimensions:", window.innerWidth, window.innerHeight);
    }

    function onMouseClick(event) {
      event.preventDefault();
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
      console.log("Mouse clicked at:", mouse.x, mouse.y);
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(scene.children, true);
      console.log("Number of intersects:", intersects.length);
      if (intersects.length > 0) {
        const obj = intersects[0].object;
        const targetPosition = new THREE.Vector3();
        obj.getWorldPosition(targetPosition);
        console.log("Clicked object:", obj.name, "at position", targetPosition);
        const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
        const newCameraPos = targetPosition.clone().add(direction.multiplyScalar(10));
        let t = 0;
        const duration = 60; // frames for transition
        const initialPos = camera.position.clone();
        const initialTarget = controls.target.clone();
        function animateCamera() {
          t++;
          const factor = t / duration;
          camera.position.lerpVectors(initialPos, newCameraPos, factor);
          controls.target.lerpVectors(initialTarget, targetPosition, factor);
          if (t < duration) {
            requestAnimationFrame(animateCamera);
          } else {
            console.log("Camera animation complete.");
          }
        }
        animateCamera();
      }
    }

    function updatePositions() {
      const diffTime = simulationDate - baseDate;
      const diffDays = diffTime / (1000 * 60 * 60 * 24);
      // Update positions for planets, moons, and probe
      scene.traverse(child => {
        if (child.type === "Group" && child.userData.orbitRadius) {
          const orbitRadius = child.userData.orbitRadius;
          const period = child.userData.orbitalPeriod;
          const angle = child.userData.initialAngle + (2 * Math.PI * (diffDays / period));
          child.position.set(orbitRadius * Math.cos(angle), 0, orbitRadius * Math.sin(angle));
          if (child.userData.moons) {
            child.userData.moons.forEach(moonPivot => {
              const mPeriod = moonPivot.userData.orbitalPeriod;
              const mAngle = moonPivot.userData.initialAngle + (2 * Math.PI * (diffDays / mPeriod));
              moonPivot.rotation.y = mAngle;
            });
          }
          child.rotation.y += 0.01;
        }
        if (child.userData.orbitRadius && child.name === "Voyager") {
          const orbitRadius = child.userData.orbitRadius;
          const period = child.userData.orbitalPeriod;
          const angle = child.userData.initialAngle + (2 * Math.PI * (diffDays / period));
          child.position.set(orbitRadius * Math.cos(angle), 0, orbitRadius * Math.sin(angle));
          child.rotation.x += 0.01;
        }
      });
    }

    function animate() {
      requestAnimationFrame(animate);
      updatePositions();
      controls.update();
      renderer.render(scene, camera);
      // Log frame render if needed (uncomment below for verbose logging)
      // console.log("Frame rendered.");
    }
  </script>
</body>
</html>
