<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Enhanced Interactive Orrery</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #202020;
      color: #fff;
      font-family: sans-serif;
    }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 20;
      background: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 5px;
    }
    #controls button,
    #controls input {
      margin: 5px;
      padding: 5px;
      background: #333;
      color: #fff;
      border: none;
      border-radius: 3px;
      cursor: pointer;
    }
    /* Use a text input for the date picker, handled by Pikaday v14*/
    #dateSelector {
      width: 120px;
      background: #fff;
      color: #000;
      border-radius: 3px;
      border: 1px solid #ccc;
      padding: 3px;
    }
    #timeSlider {
      width: 200px;
      margin-top: 5px;
    }
    .dark-mode {
      background-color: #202020;
      color: #fff;
    }
    /* Style for label divs */
    .label {
      font-size: 14px;
      font-family: sans-serif;
      color: #fff;
      background-color: rgba(0, 0, 0, 0.6);
      padding: 2px 4px;
      border-radius: 3px;
      white-space: nowrap;
    }
  </style>
  <!-- Pikaday CSS for date picker -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pikaday/css/pikaday.css">
</head>
<body>
  <div id="controls">
    <div>
      <label for="dateSelector">Select Date:</label>
      <input type="text" id="dateSelector" placeholder="YYYY-MM-DD">
      <button id="currentDateBtn">Today</button>
    </div>
    <div>
      <label for="timeSlider">Time Slider (days offset):</label>
      <input type="range" id="timeSlider" min="0" max="3650" step="1" value="0">
    </div>
    <div>
      <button id="playPauseBtn">Play</button>
      <button id="toggleScaleBtn">Toggle Scale</button>
      <button id="toggleTrailsBtn">Toggle Trails</button>
      <button id="toggleLabelsBtn">Toggle Labels</button>
      <button id="darkModeToggle">Toggle Dark Mode</button>
      <button id="resetViewBtn">Reset View</button>
    </div>
  </div>
  <canvas id="canvas"></canvas>

  <!-- Load Three.js first -->
  <script src="./js/three.min.js"></script>
  <!-- Then CSS2DRenderer from r127 via jsDelivr -->
  <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r127/examples/js/renderers/CSS2DRenderer.js"></script>
  <!-- Then Pikaday dependencies -->
  <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/moment.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pikaday@1.8.2/pikaday.js"></script>
  <!-- Then OrbitControls -->
  <script src="./js/controls/OrbitControls.js"></script>

  <script>
    console.log("Three.js, OrbitControls, and auxiliary libraries loaded.");

    if (typeof THREE === "undefined") { console.error("THREE is not loaded!"); }
    if (typeof THREE.OrbitControls === "undefined") { console.error("OrbitControls are not loaded!"); }

    let scene, camera, renderer, controls, labelRenderer;
    let raycaster, mouse;
    let celestialObjects = [];
    let orbitTrails = [];
    let labels = [];
    const baseDate = new Date("2000-01-01T00:00:00");
    let simulationDate = new Date();
    const oneDay = 1000 * 60 * 60 * 24;
    let timePaused = true;
    let playSpeed = 2; // days per frame when playing
    let scaleFactor = 1; // 1 for realistic, 5 for exaggerated
    let trailsVisible = true;
    let labelsVisible = true;

    // DOM elements
    const dateField = document.getElementById('dateSelector');
    const currentDateBtn = document.getElementById('currentDateBtn');
    const timeSlider = document.getElementById('timeSlider');
    const playPauseBtn = document.getElementById('playPauseBtn');
    const toggleScaleBtn = document.getElementById('toggleScaleBtn');
    const toggleTrailsBtn = document.getElementById('toggleTrailsBtn');
    const toggleLabelsBtn = document.getElementById('toggleLabelsBtn');
    const darkModeToggle = document.getElementById('darkModeToggle');
    const resetViewBtn = document.getElementById('resetViewBtn');

    // Initialize Pikaday date picker
    let pikaday = new Pikaday({
      field: dateField,
      format: 'YYYY-MM-DD',
      onSelect: function(date) {
        simulationDate = date;
        const daysOffset = Math.floor((simulationDate - baseDate) / oneDay);
        timeSlider.value = daysOffset;
        console.log("Date selected via calendar:", simulationDate);
      }
    });
    pikaday.setDate(simulationDate, true);
    timeSlider.value = Math.floor((simulationDate - baseDate) / oneDay);

    timeSlider.addEventListener('input', () => {
      const daysOffset = parseInt(timeSlider.value);
      simulationDate = new Date(baseDate.getTime() + daysOffset * oneDay);
      pikaday.setDate(simulationDate, true);
      console.log("Time slider set simulation date to:", simulationDate);
    });

    currentDateBtn.addEventListener('click', () => {
      simulationDate = new Date();
      pikaday.setDate(simulationDate, true);
      timeSlider.value = Math.floor((simulationDate - baseDate) / oneDay);
      console.log("Simulation date reset to current date:", simulationDate);
    });

    playPauseBtn.addEventListener('click', () => {
      timePaused = !timePaused;
      playPauseBtn.textContent = timePaused ? "Play" : "Pause";
      console.log("Time control toggled. Paused:", timePaused);
    });

    toggleScaleBtn.addEventListener('click', () => {
      scaleFactor = (scaleFactor === 1) ? 5 : 1;
      console.log("Scale factor toggled to:", scaleFactor);
      // Recreate orbital trails with new scale
      recreateTrails();
    });

    toggleTrailsBtn.addEventListener('click', () => {
      trailsVisible = !trailsVisible;
      orbitTrails.forEach(trail => { 
        trail.visible = trailsVisible; 
      });
      console.log("Orbital trails visibility set to:", trailsVisible);
    });

    toggleLabelsBtn.addEventListener('click', () => {
      labelsVisible = !labelsVisible;
      labels.forEach(label => {
        label.element.style.display = labelsVisible ? 'block' : 'none';
      });
      console.log("Labels visibility set to:", labelsVisible);
    });

    darkModeToggle.addEventListener('click', () => {
      document.body.classList.toggle('dark-mode');
      if (document.body.classList.contains('dark-mode')) {
        renderer.setClearColor(0x202020);
        console.log("Dark mode activated.");
      } else {
        renderer.setClearColor(0xffffff);
        console.log("Dark mode deactivated.");
      }
    });

    resetViewBtn.addEventListener('click', () => {
      camera.position.set(0, 50, 100);
      controls.target = new THREE.Vector3(0, 0, 0);
      console.log("View reset to default.");
    });

    init();
    animate();

    function init() {
      console.log("Initialization started.");
      const canvas = document.getElementById('canvas');
      if (!canvas) {
        console.error("Canvas element not found!");
        return;
      }

      renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x202020);
      console.log("Renderer created.");

      // Set up CSS2DRenderer for labels
      labelRenderer = new THREE.CSS2DRenderer();
      labelRenderer.setSize(window.innerWidth, window.innerHeight);
      labelRenderer.domElement.style.position = 'absolute';
      labelRenderer.domElement.style.top = '0px';
      labelRenderer.domElement.style.pointerEvents = 'none';
      document.body.appendChild(labelRenderer.domElement);
      console.log("CSS2DRenderer initialized.");

      scene = new THREE.Scene();
      console.log("Scene created.");

      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(0, 50, 100);
      console.log("Camera created at position:", camera.position);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      console.log("OrbitControls initialized.");

      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();
      console.log("Raycaster and mouse vector created.");

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      const pointLight = new THREE.PointLight(0xffffff, 1.5);
      pointLight.position.set(0, 0, 0);
      scene.add(pointLight);
      console.log("Lights added.");

      // Create the Sun
      const sunGeometry = new THREE.SphereGeometry(3, 32, 32);
      const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
      const sun = new THREE.Mesh(sunGeometry, sunMaterial);
      sun.name = "Sun";
      scene.add(sun);
      celestialObjects.push({ mesh: sun, type: 'sun' });
      createLabel(sun, "Sun");
      console.log("Sun created.");

      // Planetary data
      const planetsData = [
        { name: "Mercury", radius: 4, period: 88, size: 0.5, color: 0xaaaaaa, moons: [] },
        { name: "Venus",   radius: 7, period: 225, size: 0.8, color: 0xffcc66, moons: [] },
        { name: "Earth",   radius: 10, period: 365, size: 0.9, color: 0x2233ff, moons: [
            { name: "Moon", orbit: 1.5, period: 27, size: 0.3, color: 0x888888 }
          ] },
        { name: "Mars",    radius: 13, period: 687, size: 0.7, color: 0xff3300, moons: [
            { name: "Phobos", orbit: 1, period: 0.3, size: 0.15, color: 0x999999 },
            { name: "Deimos", orbit: 1.5, period: 1.3, size: 0.1, color: 0xbbbbbb }
          ] },
        { name: "Jupiter", radius: 17, period: 4333, size: 2, color: 0xffaa77, moons: [
            { name: "Io", orbit: 2.5, period: 1.8, size: 0.3, color: 0xffddaa },
            { name: "Europa", orbit: 3, period: 3.5, size: 0.28, color: 0xffffff },
            { name: "Ganymede", orbit: 3.5, period: 7, size: 0.4, color: 0xcccccc },
            { name: "Callisto", orbit: 4, period: 16, size: 0.35, color: 0x999999 }
          ] },
        { name: "Saturn",  radius: 21, period: 10759, size: 1.8, color: 0xffeeaa, moons: [
            { name: "Titan", orbit: 3, period: 16, size: 0.4, color: 0xffcc99 },
            { name: "Enceladus", orbit: 2, period: 1.4, size: 0.2, color: 0xdddddd }
          ] },
        { name: "Uranus",  radius: 25, period: 30687, size: 1.5, color: 0x66ccff, moons: [
            { name: "Titania", orbit: 2.5, period: 8, size: 0.3, color: 0xccccff },
            { name: "Oberon", orbit: 3, period: 12, size: 0.3, color: 0xbbbbff }
          ] },
        { name: "Neptune", radius: 29, period: 60190, size: 1.5, color: 0x3366ff, moons: [
            { name: "Triton", orbit: 3, period: 5, size: 0.35, color: 0x9999ff }
          ] },
        { name: "Pluto",   radius: 33, period: 90560, size: 0.6, color: 0xcccccc, moons: [
            { name: "Charon", orbit: 1.5, period: 6.4, size: 0.3, color: 0x888888 }
          ] }
      ];

      planetsData.forEach(planet => {
        const planetGroup = new THREE.Group();
        const geometry = new THREE.SphereGeometry(planet.size, 32, 32);
        const material = new THREE.MeshStandardMaterial({ color: planet.color });
        const planetMesh = new THREE.Mesh(geometry, material);
        planetMesh.name = planet.name;
        planetGroup.add(planetMesh);
        planetGroup.userData = {
          orbitRadius: planet.radius,
          orbitalPeriod: planet.period,
          initialAngle: Math.random() * Math.PI * 2,
          moons: []
        };
        createLabel(planetMesh, planet.name);
        planet.moons.forEach(moon => {
          const moonGeometry = new THREE.SphereGeometry(moon.size, 16, 16);
          const moonMaterial = new THREE.MeshStandardMaterial({ color: moon.color });
          const moonMesh = new THREE.Mesh(moonGeometry, moonMaterial);
          moonMesh.position.x = moon.orbit;
          moonMesh.name = moon.name;
          createLabel(moonMesh, moon.name);
          const moonPivot = new THREE.Group();
          moonPivot.add(moonMesh);
          moonPivot.userData = {
            orbitRadius: moon.orbit,
            orbitalPeriod: moon.period,
            initialAngle: Math.random() * Math.PI * 2
          };
          planetGroup.add(moonPivot);
          planetGroup.userData.moons.push(moonPivot);
          console.log(`Moon ${moon.name} added to planet ${planet.name}.`);
        });
        scene.add(planetGroup);
        celestialObjects.push({ mesh: planetGroup, type: 'planet', data: planet });
        console.log(`Planet ${planet.name} created with orbit radius ${planet.radius}.`);
        createOrbitTrail(planetGroup.userData.orbitRadius * scaleFactor);
      });

      // Asteroid Belt (between Mars and Jupiter, approx. 15-17)
      const asteroidBelt = new THREE.Group();
      const asteroidCount = 100;
      for (let i = 0; i < asteroidCount; i++) {
        const asteroidGeometry = new THREE.SphereGeometry(0.07, 6, 6);
        const asteroidMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });
        const asteroid = new THREE.Mesh(asteroidGeometry, asteroidMaterial);
        const angle = Math.random() * Math.PI * 2;
        const distance = 15 + Math.random() * 2;
        asteroid.position.set(distance * Math.cos(angle), (Math.random() - 0.5) * 0.5, distance * Math.sin(angle));
        asteroidBelt.add(asteroid);
      }
      scene.add(asteroidBelt);
      // Use a custom offset for belt labels (e.g. y=5)
      createLabel(asteroidBelt, "Asteroid Belt", {x:0, y:5, z:0});
      console.log("Asteroid Belt created.");

      // Kuiper Belt (beyond Pluto, approx. 35-45)
      const kuiperBelt = new THREE.Group();
      const kuiperCount = 150;
      for (let i = 0; i < kuiperCount; i++) {
        const kuiperGeom = new THREE.SphereGeometry(0.08, 6, 6);
        const kuiperMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
        const kuiperObj = new THREE.Mesh(kuiperGeom, kuiperMat);
        const angle = Math.random() * Math.PI * 2;
        const distance = 35 + Math.random() * 10;
        kuiperObj.position.set(distance * Math.cos(angle), (Math.random() - 0.5) * 1, distance * Math.sin(angle));
        kuiperBelt.add(kuiperObj);
      }
      scene.add(kuiperBelt);
      createLabel(kuiperBelt, "Kuiper Belt", {x:0, y:5, z:0});
      console.log("Kuiper Belt created.");

      // Probes: Voyager 1 (red) and Voyager 2 (orange)
      const probeGeometry = new THREE.BoxGeometry(0.5, 0.5, 1);
      const voyager1Material = new THREE.MeshStandardMaterial({ color: 0xff0000 });
      const voyager1 = new THREE.Mesh(probeGeometry, voyager1Material);
      voyager1.name = "Voyager 1";
      voyager1.userData = {
        orbitRadius: 38,
        orbitalPeriod: 150000,
        initialAngle: Math.random() * Math.PI * 2
      };
      scene.add(voyager1);
      celestialObjects.push({ mesh: voyager1, type: 'probe' });
      createLabel(voyager1, "Voyager 1");
      createOrbitTrail(voyager1.userData.orbitRadius * scaleFactor);
      console.log("Voyager 1 created.");

      const voyager2Material = new THREE.MeshStandardMaterial({ color: 0xff6600 });
      const voyager2 = new THREE.Mesh(probeGeometry, voyager2Material);
      voyager2.name = "Voyager 2";
      voyager2.userData = {
        orbitRadius: 42,
        orbitalPeriod: 160000,
        initialAngle: Math.random() * Math.PI * 2
      };
      scene.add(voyager2);
      celestialObjects.push({ mesh: voyager2, type: 'probe' });
      createLabel(voyager2, "Voyager 2");
      createOrbitTrail(voyager2.userData.orbitRadius * scaleFactor);
      console.log("Voyager 2 created.");

      window.addEventListener('click', onMouseClick, false);
      window.addEventListener('resize', onWindowResize, false);
      console.log("Event listeners added.");
    }

    // Create a label using CSS2DRenderer with an optional offset
    function createLabel(object, text, offset) {
      const div = document.createElement('div');
      div.className = 'label';
      div.textContent = text;
      const label = new THREE.CSS2DObject(div);
      // Use provided offset or default to (0, 1.2, 0)
      if (offset) {
        label.position.set(offset.x, offset.y, offset.z);
      } else {
        label.position.set(0, 1.2, 0);
      }
      object.add(label);
      labels.push(label);
      console.log(`Label "${text}" created with offset:`, offset || {x:0, y:1.2, z:0});
    }

    // Create an orbital trail (a circular line loop) for a given orbit radius
    function createOrbitTrail(orbitRadius) {
      const segments = 64;
      const geometry = new THREE.BufferGeometry();
      const positions = [];
      for (let i = 0; i <= segments; i++) {
        const theta = (i / segments) * Math.PI * 2;
        positions.push(orbitRadius * Math.cos(theta), 0, orbitRadius * Math.sin(theta));
      }
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      const material = new THREE.LineBasicMaterial({ color: 0xffffff, opacity: 0.3, transparent: true });
      const line = new THREE.LineLoop(geometry, material);
      scene.add(line);
      orbitTrails.push(line);
      console.log("Orbit trail created for orbit radius:", orbitRadius);
    }

    // Remove and recreate all orbital trails (for scale changes)
    function recreateTrails() {
      console.log("Recreating orbital trails with new scale factor:", scaleFactor);
      orbitTrails.forEach(trail => { 
        scene.remove(trail); 
      });
      orbitTrails = [];
      // Recreate trails for each planet
      celestialObjects.forEach(obj => {
        if (obj.type === 'planet' || obj.type === 'probe') {
          const orbitRadius = obj.mesh.userData.orbitRadius || obj.mesh.userData.orbitRadius; // For probes and planets
          if (orbitRadius !== undefined) {
            createOrbitTrail(orbitRadius * scaleFactor);
          }
        }
      });
      console.log("Orbital trails recreated.");
    }

    // Update positions based solely on simulationDate and scaleFactor
    function updatePositions() {
      const diffTime = simulationDate - baseDate;
      const diffDays = diffTime / oneDay;
      scene.traverse(child => {
        if (child.type === "Group" && child.userData.orbitRadius) {
          const orbitRadius = child.userData.orbitRadius * scaleFactor;
          const period = child.userData.orbitalPeriod;
          const angle = child.userData.initialAngle + (2 * Math.PI * (diffDays / period));
          child.position.set(orbitRadius * Math.cos(angle), 0, orbitRadius * Math.sin(angle));
          if (child.userData.moons) {
            child.userData.moons.forEach(moonPivot => {
              const mPeriod = moonPivot.userData.orbitalPeriod;
              const mAngle = moonPivot.userData.initialAngle + (2 * Math.PI * (diffDays / mPeriod));
              moonPivot.rotation.y = mAngle;
            });
          }
        }
        if (child.userData.orbitRadius && (child.name === "Voyager 1" || child.name === "Voyager 2")) {
          const orbitRadius = child.userData.orbitRadius * scaleFactor;
          const period = child.userData.orbitalPeriod;
          const angle = child.userData.initialAngle + (2 * Math.PI * (diffDays / period));
          child.position.set(orbitRadius * Math.cos(angle), 0, orbitRadius * Math.sin(angle));
        }
      });
    }

    function onMouseClick(event) {
      event.preventDefault();
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(scene.children, true);
      console.log("Number of intersects:", intersects.length);
      if (intersects.length > 0) {
        const obj = intersects[0].object;
        const targetPosition = new THREE.Vector3();
        obj.getWorldPosition(targetPosition);
        console.log("Clicked object:", obj.name, "at", targetPosition);
        const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
        const newCameraPos = targetPosition.clone().add(direction.multiplyScalar(10));
        let t = 0;
        const duration = 60;
        const initialPos = camera.position.clone();
        const initialTarget = controls.target.clone();
        function animateCamera() {
          t++;
          const factor = t / duration;
          camera.position.lerpVectors(initialPos, newCameraPos, factor);
          controls.target.lerpVectors(initialTarget, targetPosition, factor);
          if (t < duration) {
            requestAnimationFrame(animateCamera);
          } else {
            console.log("Camera animation complete.");
          }
        }
        animateCamera();
      }
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      labelRenderer.setSize(window.innerWidth, window.innerHeight);
      console.log("Window resized. New dimensions:", window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      if (!timePaused) {
        simulationDate = new Date(simulationDate.getTime() + playSpeed * oneDay);
        const daysOffset = Math.floor((simulationDate - baseDate) / oneDay);
        timeSlider.value = daysOffset;
        pikaday.setDate(simulationDate, true);
      }
      updatePositions();
      controls.update();
      renderer.render(scene, camera);
      labelRenderer.render(scene, camera);
    }
  </script>
</body>
</html>
